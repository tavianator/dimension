#!/usr/bin/python3

#########################################################################
# Copyright (C) 2011 Tavian Barnes <tavianator@tavianator.com>          #
#                                                                       #
# This file is part of Dimension.                                       #
#                                                                       #
# Dimension is free software; you can redistribute it and/or modify it  #
# under the terms of the GNU General Public License as published by the #
# Free Software Foundation; either version 3 of the License, or (at     #
# your option) any later version.                                       #
#                                                                       #
# Dimension is distributed in the hope that it will be useful, but      #
# WITHOUT ANY WARRANTY; without even the implied warranty of            #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     #
# General Public License for more details.                              #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################

import argparse
import os.path
import sys

# Display a progress bar
def progress_bar(str, progress):
  if not _args.quiet:
    print(str, end = ' ')
    sys.stdout.flush()

    term_width = terminal_width()
    width = term_width - (len(str) + 1)%term_width
    for i in range(width):
      progress.wait(i/width)
      print('.', end = '')
      sys.stdout.flush()

    print()
    sys.stdout.flush()

  progress.finish()

# Parse the command line
_parser = argparse.ArgumentParser(
  epilog = "@PACKAGE_STRING@\n"
           "@PACKAGE_URL@\n"
           "Copyright (C) 2009-2011 Tavian Barnes <@PACKAGE_BUGREPORT@>\n"
           "Licensed under the GNU General Public License",
  formatter_class = argparse.RawDescriptionHelpFormatter,
  conflict_handler = "resolve", # For -h as height instead of help
)

_parser.add_argument("-V", "--version", action = "version",
                     version = "@PACKAGE_STRING@")

_parser.add_argument("-w", "--width", action = "store", type = int,
                     default = 768, help = "image width")
_parser.add_argument("-h", "--height", action = "store", type = int,
                     default = 480, help = "image height")

_parser.add_argument("-v", "--verbose", action = "store_true",
                     help = "print more information")
_parser.add_argument("-q", "--quiet", action = "store_true",
                     help = "print less information")

_parser.add_argument("--strict", action = "store_true",
                     help = "treat warnings as errors")
_parser.add_argument("--threads", action = "store", type = int,
                     help = "the number of threads to render with")
_parser.add_argument("--quality", action = "store", type = int,
                     help = "the scene quality")

_parser.add_argument("-o", "--output", action = "store", type = str,
                     help = "the output image file")
_parser.add_argument("input", action = "store", type = str,
                     help = "the input scene description file")

_args = _parser.parse_args()

# Default output is basename(input).png
if _args.output is None:
  _noext = os.path.splitext(os.path.basename(_args.input))[0]
  _args.output = _noext + ".png"

# Imports available to scripts
from math import *
from dimension import *

# --strict option
die_on_warnings(_args.strict)

# Defaults
objects          = []
lights           = []
camera           = PerspectiveCamera()
default_texture  = Texture(finish = Ambient(0.1) + Diffuse(0.6))
default_interior = Interior()
background       = Black
sky_sphere       = None
recursion_limit  = None

# Execute the input script
if not _args.quiet:
  print("Parsing scene ...")

parse_timer = Timer()
with open(_args.input) as _fh:
  exec(compile(_fh.read(), _args.input, "exec"))
parse_timer.complete()

# Make the canvas
canvas = Canvas(width = _args.width, height = _args.height)
canvas.optimize_PNG()

# Make the scene object
scene = Scene(canvas  = canvas,
              objects = objects,
              lights  = lights,
              camera  = camera)
scene.default_texture = default_texture
scene.background      = background
if sky_sphere is not None:
  scene.sky_sphere = sky_sphere
if recursion_limit is not None:
  scene.recursion_limit = recursion_limit
if _args.threads is not None:
  scene.nthreads = _args.threads
if _args.quality is not None:
  scene.quality = _args.quality

# Raytrace the scene
if scene.nthreads == 1:
  render_message = "Rendering scene"
else:
  render_message = "Rendering scene (using %d threads)" % scene.nthreads
progress_bar(render_message, scene.raytrace_async())

# Write the output file
export_timer = Timer()
progress_bar("Writing %s" % _args.output, canvas.write_PNG_async(_args.output))
export_timer.complete()

# Print execution times
if _args.verbose:
  print()
  print("Parsing time:   ", parse_timer)
  print("Bounding time:  ", scene.bounding_timer)
  print("Rendering time: ", scene.render_timer)
  print("Exporting time: ", export_timer)
